# CH8-2

![](/Images/c98bba4c-19c1-496b-b91a-01cf97ece242.png)

![](/Images/aef81272-b62e-4fc2-a424-86cfb35928ce.png)

![](/Images/46a2a009-94dc-40ec-9ebc-9c31f9a37cd3.png)

![](/Images/a0a329b2-e66e-4e1d-a515-37ebae3c99b6.png)

![](/Images/bc083165-a5c5-4694-a15f-925dd135ae8f.png)

![](/Images/dab2ef50-8057-4fe1-a543-e9ae55111243.png)

![](/Images/08c0d2b3-9b13-4ea4-b726-2090ff12fdbf.png)

![](/Images/ce3fdd83-7445-48d6-9c64-32bc4233be7c.png)

### 消息完整性与认证

- 从爱丽丝处接收消息时，鲍勃希望确保：
  - 消息确实源自爱丽丝
  - 消息自爱丽丝发送后未被篡改

- 安全处理问题：
  - 源身份伪造 / 欺骗
  - 消息注入 / 修改
  - 消息重排序 / 重放

### 认证功能

- 生成一个认证符，其可能涉及以下要素的函数：
  - 发送方 / 消息文本
  - 时间戳 / 序列号 / 随机值
  - 秘密密钥
- 发送方计算认证符并将其作为常规消息的一部分发送
- 接收方将接收到的认证符与预期认证符进行比对

![](/Images/19313dab-957d-46a6-aa19-be2d9aebeb7e.png)

### 通过 MAC 进行认证

- MAC 是附加在消息后的固定长度代码
  - MAC 的典型长度范围为 64 到 256 位
- 消息可明文发送（无需加密）
- MAC 是消息与秘密密钥的函数
  - 可确保消息未被篡改且来自声称的发送方
- MAC 不应可逆，无需解密
- MAC 的强度取决于所使用的函数及密钥的保密性

### 认证方法

- 加密认证
  - 使用消息文本和秘密密钥的加密函数
  - CBC-MAC（密码块链接消息认证码）
- 哈希认证
  - 使用哈希函数并在计算中引入秘密密钥
  - MD5：128 位 MAC（RFC 1321 标准）
  - SHA-1：160 位 MAC（美国国家标准与技术研究院 NIST，FIPS PUB 180-1 标准）

### MAC 函数的要求

- 可操作性
  - 适用于任意输入长度
  - 生成固定大小的输出
  - 应易于计算
- 安全性
  - 单向性 —— 给定值 Y，难以找到内容 X 使得 Y = MAC (X)
  - 弱抗碰撞性 —— 给定内容 X₁，难以找到另一内容 X₂使得 MAC (X₁) = MAC (X₂)
  - 强抗碰撞性 —— 难以找到任意两个不同的内容 X₁和 X₂使得 MAC (X₁) = MAC (X₂)

### CBC-MAC 认证

- 密码块链接消息认证码
- 将消息 M 划分为 L 个长度均为 n 位的块：M = M₁, M₂, . . ., Mₗ
- 设 K 为加密算法 E 的秘密密钥
- 设 C₀ = IV 为 n’位的随机块
- 对 i = 1, 2, . . ., L，计算 Cᵢ = Eₖ(Mᵢ + Cᵢ₋₁)
  - CBC-MACₖ(M) = Cₗ
- 令 MACₖ(M) = (C₀, Cₗ) = (IV, CBC-MACₖ(M))
  - 即 CBC 加密的第一个块和最后一个块

![](/Images/e8369f6b-6b9f-4393-8894-25153ae5b2b4.png)

### 通用步骤

- 输入消息长度小于 2⁶⁴位
  - 按 512 位块进行处理
- 附加填充位
  - 使消息长度满足模 512 余 448
- 添加长度字段
  - 原始消息长度写入最后 64 位

### MD5 处理

- 使用 4 字状态缓冲区 A、B、C、D 计算消息摘要
  - 初始值：01234567、89abcdef、fedcba98、76543210
  - 共 128 位
- 按 16 字块处理消息
  - M0、M1、…M15
- 消息块的处理包含 4 个相似阶段
  - 每个阶段使用不同的函数 F
- 每个阶段由 16 个相似操作组成
  - 采用函数 F、模加运算和左旋转

![](/Images/50095f40-9d58-44a4-b942-09d47f667fd0.png)

### SHA-1 处理

- 使用 5 字状态缓冲区 A、B、C、D、E 计算消息摘要
  - 初始值：67452301、efcdab89、98badcfe、10325476、c3d2e1f0
  - 共 160 位
- 按 16 字块处理消息
  - M0、M1、…M15
- 消息块的处理包含 4 个相似阶段
  - 每个阶段使用不同的函数 F
- 每个阶段由 20 个相似操作组成

![](/Images/c0e428bc-16e2-4655-ae36-eea01a5f203c.png)

### 一次 SHA 操作

- F 是一个会变化的非线性函数
- Wt 是第 t 步的扩展消息字
- Kt 是第 t 步的常数

![](/Images/e3e53160-07cf-4d48-95c8-0316561be9d8.png)

![](/Images/5c180d39-84d5-421c-adf5-c518964842ef.png)

---



## 数字签名

- 发送方（鲍勃）对文档进行数字签名，以此表明其为文档的所有者 / 创建者
- 接收方（爱丽丝）可向他人证明该文档必定由鲍勃（而非其他人）创建
- 鲍勃的私钥至关重要

![](/Images/5b0dfa74-b523-4b9c-a1da-128d683d1579.png)

![](/Images/78436989-d984-4509-bcc9-9bd7dffac821.png)

### 密钥分发

- 问题
  - 爱丽丝和鲍勃如何共享共同的秘密密钥
  - 爱丽丝如何知道鲍勃的公钥确实是鲍勃的公钥
- 解决方案
  - 迪菲 - 赫尔曼密钥交换
  - 可信证书颁发机构（CA）
  - 公钥证书

### 攻击密钥分发

- 记录与重放
  - 仍是秘密漏洞的主要组成部分
  - 需合理使用时间戳和不重数

![](/Images/032878cb-7677-43fe-9220-2b18abbb67fe.png)

### 攻击密钥分发

- 中间人攻击（Man-in-the-middle attack）
  - 特鲁迪（Trudy）伪装成爱丽丝（对鲍勃）和鲍勃（对爱丽丝）
- 难以察觉
  - 鲍勃接收爱丽丝发送的所有内容，反之亦然
  - 但特鲁迪也会接收所有消息！

![](/Images/10a7bf9a-4bbf-4d51-b603-08d9bb55de93.png)

### 动机：特鲁迪对鲍勃实施披萨恶作剧

- 特鲁迪创建电子邮件订单：
- 亲爱的披萨店，请给我送四个意大利辣香肠披萨。谢谢，鲍勃
- 特鲁迪用自己的私钥对订单签名
- 特鲁迪将订单发送给披萨店
- 特鲁迪向披萨店发送自己的公钥，但谎称是鲍勃的公钥
- 披萨店验证签名后，将四个意大利辣香肠披萨送到鲍勃处
- 而鲍勃根本不喜欢意大利辣香肠

---

### Diffie-Hellman 密钥交换（1）

- 预备知识
- 公开的大素数 P
- 公开的 Zp*生成元 g
- A 和 B 之间没有共享的秘密值
- Zp* = {1, 2, ..., p-1}（模 p 运算）

### Diffie-Hellman 密钥交换（2）

- D-H 协议
  - A 随机选取一个数 X∈{1, 2, ..., P–1}，并向 B 发送值 g^X (mod P)
  - B 随机选取一个数 Y∈{1, 2, ..., P–1}，并向 A 发送值 g^Y (mod P)
  - A 计算 (g^Y)^X (mod P) = g^(XY) (mod P)
  - B 计算 (g^X)^Y (mod P) = g^(XY) (mod P)
  - 此时 A 和 B 共享秘密值 g^(XY) (mod P)

注释：

- ZP* = {1≤a≤P–1: gcd(a,P)=1}
  - 每个 [a] 表示集合 [a] = {a+k×P: k∈Z}
  - 若 P 为素数，则 ZP* = {1, 2, ..., P–1}
- ZP*的生成元 g 满足：g∈ZP*，且对任意 a∈ZP*，存在 k∈Z 使得 a = g^k (mod P)

![](/Images/cde3a44e-b98c-4564-ad03-60964d36d572.png)

![](/Images/de40a614-c8c7-44ea-b81e-dde30fafd2a5.png)

![](/Images/dbd92247-04b8-4f58-bc14-4f09158843d3.png)

### 通过 CA 进行密钥分发

- 会话密钥
  - 在一次逻辑连接期间使用
  - 会话结束时销毁
- 永久密钥
  - 用于密钥的分发
- 密钥分发中心（CA）
  - 确定发送方和接收方的有效性
  - 为该连接提供一个会话密钥
- 安全服务模块（SSM）
  - 执行端到端加密
  - 为主机获取密钥

### Needham-Schroder 协议

1. 客户端（C）向认证服务器（AS）发送包含自身标识、服务器（S）标识及随机数（Nc）的票据
2. AS 使用与客户端共享的密钥（Kc-as）加密生成的会话密钥（Kcs）、服务器标识、随机数等信息，并通过与服务器共享的密钥（Ks-as）加密会话密钥和客户端标识生成票据，一同发送给客户端
3. 客户端告知 AS 希望与服务器通信
4. AS 生成会话密钥 Kcs 和票据，发送给客户端
5. 客户端将票据发送至服务器，服务器可使用 Ks-as 解密票据
6. 服务器用获得的会话密钥 Kcs 加密新随机数（Ns）并发送给客户端
7. 客户端将该随机数减 1 后用 Kcs 加密回传，证明通信正常

AS：认证服务器（密钥分发中心）
C：客户端
S：服务器
Kx-as：实体 X（C 或 S）与 AS 共享的密钥
Kcs：客户端 C 与服务器 S 之间的会话密钥
Nx：实体 X 生成的随机数

![](/Images/599182c0-22d1-46e8-a0c5-8dde6d7468db.png)

### 一次性会话密钥

- 公钥不适合加密大块消息
- 鲍勃与爱丽丝的通信步骤如下：
  - 准备一条消息
  - 使用对称加密算法和一次性会话密钥对消息进行加密
  - 用爱丽丝的公钥加密该会话密钥
  - 将加密后的会话密钥附加到消息上并发送给爱丽丝
  - 爱丽丝用自己的私钥获取会话密钥，然后解密消息

### 公钥证书

- 问题
  - 如何确保发布的公钥确实属于爱丽丝，而非他人
- 解决方案：公钥证书
  - 包含公钥及密钥所有者的用户标识
  - 上述信息块由可信证书颁发机构（CA）签名并附加时间戳
- 他人无法用自己的公钥替换爱丽丝的公钥
-  无法伪造可信 CA 的签名

![](/Images/71b2374b-2e63-4afd-b608-345358486a53.png)

### 公钥证书

- 序列号（此证书唯一）
- 证书所有者信息，包括使用的算法和密钥值
- 证书颁发者信息，包括有效期、颁发者的数字签名（指纹）

### 安全电子邮件

爱丽丝想向鲍勃发送机密电子邮件 m。
爱丽丝操作如下：
▪ 生成随机对称私钥 KS
▪ 用 KS 加密消息（为提高效率）
▪ 同时用鲍勃的公钥加密 KS
▪ 将 KS (m) 和 KB (KS) 一并发送给鲍勃

![](/Images/b88a5398-2b4f-4249-99d6-0253160ae555.png)

爱丽丝希望提供发送方身份认证和消息完整性保障。
▪ 爱丽丝对消息进行数字签名
▪ 同时发送明文消息和数字签名

![](/Images/4b152798-1c0f-4443-8c91-2c4ad14bdabd.png)

爱丽丝希望实现保密性、发送方身份认证和消息完整性。

爱丽丝使用三个密钥：她的私钥、鲍勃的公钥以及新创建的对称密钥。

![](/Images/3c4bd198-7455-47b6-a8c2-7e786bdcdc4c.png)

---

![](/home/guan/.config/Typora/typora-user-images/image-20250615211823158.png)
